#!/usr/bin/env perl
require 5.012;
package LogClean v11.2.2;

use warnings;
use strict;
use integer;

use File::Path v2.6.5 ();
use Getopt::Long 2.24 ();
use String::ShellQuote ();
use Term::ANSIColor 2.01 qw(colorstrip);
#use Pod::Usage ();
#use File::Which (); # not mandatory but recommended; there are fallbacks

=head1 NAME

logclean - Remove unneeded portage log- and tempfiles

=head1 SYNOPSIS

B<logclean> [options] B<all>|B<emerge>|B<log>|B<elog>|B<notices>|B<cache>|B<revdep>|B<builds>|B<man>|B<help>

B<logclean> [options] B<shorten> I<logfile1> I<logfile2> ...

B<logclean> [options] B<uncolor> I<logfile1> I<logfile2> ...

To get an extended help, type B<logclean --man> or B<logclean man>

=head1 DESCRIPTION

This script can remove all logfiles of portage which do not correspond to
currently installed packages and shorten/compress the other ones.
It can also remove the tempfiles of portage.
What should be removed must be specified in the argument.

(It is possible to specify several arguments which is similar as
calling B<logclean> repeatedly which these arguments;
if B<shorten> or B<uncolor> is used, it must be the last.)

=over 8

=item B<logclean> [options] B<all>

Do all of the following cleanups in this order
(do not use B<all> if portage might be running, e.g. in a cron job):

=item B<logclean> [options] B<emerge>

Remove everything from F</var/log/emerge.log> except for the latest
begin/end emerge entries of installed packages (used by qlop or genlop)
and except for the data of the latest 100 (by default) calls of portage.

=item B<logclean> [options] B<log[s]>

Remove unneded files in ${PORT_LOGDIR} (defaults to /var/log/portage).
A logfile counts as unneeded if no corresponding package seems to be
installed, if there appears to be a newer installation logfile,
or if it does not appear to be an installation logfile at all.
Moreover, all "needed" logfiles are compressed with xz/lzma/bzip2/gzip;
additionally, logfiles of packages specified in F</etc/logclean.conf>
are shortened and all color sequences are removed (unless B<--keepcolor>
is specified).

=item B<logclean> [options] B<elog[s]>

Remove unneded files in ${PORT_LOGDIR}/elog

A file here counts as unneeded if no corresponding package seems to be
installed, if there appears to be a newer logfile, or if the file appears
to contain only "standard" messages.

=item B<logclean> [options] B<not[ic]es>

Remove unneded files in ${PORT_ENOTICE_DIR} (usually /var/log/notices).

The notices stem from an unofficial extension of the portage logging facility
(before elog was officially supported by portage) which was introduced in
connection with the "enotice" script.

A file here counts as unneeded if no corresponding package seems to be
installed, if there appears to be a newer logfile, or if the file appears
to contain only "standard" messages.

=item B<logclean> [options] B<cache>

Remove all files/dirs in /var/cache/edb/dep (unless their mtime is not older
than specified by the -o option).

This directory contains only caches which are rebuild if necessary.

=item B<logclean> [options] B<revdep>

Remove all files/dirs in /var/cache/revdep-rebuild
(unless their mtime is not older than specified by the -o option).

=item B<logclean> [options] B<builds>

Remove all unneded data in ${PORT_TMPDIR}/portage (usually /var/tmp/portage).

Any directory here (with all its contents) except for F<homedir> is
considered as unneeded (unless its mtime is not older than specified
by the -o option).

Do not use B<builds> (or B<all>) if portage might be running
(in particular, do not use B<build> or B<all> in a cron job)!

=item B<logclean> [options] B<cache>

Remove all files/dirs in /var/cache/edb/dep (unless their mtime is not older
than specified by the -o option).

This directory contains only caches which are rebuild if necessary.

=back

There are two special calls (not included in B<all>):

=over 8

=item B<logclean> [options] B<shorten> I<logfile1> I<logfile2> ...

This will shorten all logfiles given as arguments (if they can be shortened).
Almost no sanity checks are done: It is the caller's responsibility to
make sure that the arguments are uncompressed logfiles,
otherwise data damage may occur in these files.

=item B<logclean> [options] B<uncolor> I<logfile1> I<logfile2> ...

This is similar to B<shorten> with the difference that only color escape
sequences are removed.

=back

=head1 OPTIONS

=over 8

=item B<--help> or B<-h>

Display brief help

=item B<--man> or B<-?>

Display extended help as a manpage

=item B<--version> or B<-V>

Output current version and exit

=item B<--oldformat> or B<-O>

Assume that the logfiles are in the old format (<portage-2.1.1)

=item B<--pretend> or B<--show> or B<-p> or B<-s>

Show only what would be removed, do not remove anything

=item B<--root=>I<rootdir> or B<-r> I<rootdir>

Consider I<rootdir> instead of '/' as the root of all directories

=item B<--keep=>I<keepcalls> or B<-k> I<keepcalls>

When cleaning F</var/log/emerge.log> keep all data of the latest I<keepcalls>
calls of portage, independent of their content. The default is 100.

=item B<--older=>I<h> or B<-o> I<h>

Delete only files/dirs if they are older than I<h> hours.
This is useful if you run this script e.g. in a cron job and a
simultaneous "emerge" happens: You usually do not want to remove a
currently created logfile or a build directory which portage uses
in this moment.

=item B<--newer=>I<h> or B<-n> I<h>

Skip scanning of some files which are older than I<h> hours,
i.e. require that scanned files are at leat I<h> hours new.
The purpose is to speed up the processing of the script, considering
only new changes, at the small risk of possibly not deleting all
unneeded files.

This is essentially only useful in connection with <portage-2.1.1, namely
if an emerge just failed and you want to erase the latest "failed" log(s)
to avoid that the output of the next emerge is appended to them.

=item B<--shorten=>I<mask> or B<-S> I<mask>

Acts as if the content of I<mask> was added to F</etc/logclean.conf>
It is possible to use this option repeatedly and to combine it with the
option B<--shortenfile>; all these options will take effect in the order
they are passed to B<logclean>.
In particular, B<--shorten=-> will cancel all from F</etc/logclean.conf>.
If you want to shorten always, use B<-S*> (must be quoted in shells!).

=item B<--shortenfile=>I<file> or B<-f> I<file>

Act as if the content of I<file> was added to F</etc/logclean.conf>;
the particular filename B<-> means to use standard input.
I<file> can thus override the defaults from F</etc/logclean.conf>,
since later entries can override previous ones (see the description below).
It is possible to use this option repeatedly and to combine it
with B<--shorten> described above; all these options will take effect
in the order they are passed to B<logclean>.

For instance, to substitute F</etc/logclean.conf> by
F</usr/local/etc/logclean.conf> you can pass the options
B<-S-> B<-f/usr/local/etc/logclean.conf> in this order to B<logclean>
(B<-S-> is not necessary if the first line in F</usr/local/etc/logclean.conf>
is the line B<-> which means that all previous entries are ignored.)

=item B<--keepcolor> or B<-C>

Do not remove the ANSI color sequences.

=item B<--xz> or B<-x>

Use xz for compression (default if available).
You might want to set something like XZ_OPT="--extreme -5" in the environment.

=item B<--lzma> or B<-l>

Use lzma for compression (default if the above are not available).

=item B<--bzip2> or B<-b>

Use bzip2 for compression (default if the above are not available).

=item B<--gzip> or B<-g>

Use gzip for compression (default if the above are not available).

=item B<--compprog=>I<program> or B<-c> I<program>

Use I<program> as compression program.
Use an empty string if you want no compression.

=item B<--ignore> or B<-i>

When shortening F</var/log/emerge.log> do not take installed packages into
account but only rely on unmerge entries in the file itself.

=item B<--debug> or B<-d> or B<-D>

Before deleting a logfile print the reason to stderr.
In addition, do not shorten F</var/log/emerge.log>
but only print the new version to stdout.

=item B<-->

Last option

=back

=head1 /etc/logclean.conf

Typically, logs of some packages (like sys-kernel/gentoo-sources)
are long but rather unimportant except for a few informal messages.
Therefore, by default these logs are shortened to lines with informal messages.
The default for which packages this happens is specified in /etc/logclean.conf.
The format of this file is as follows:
Comment lines are marked with '#'; all other lines are in one of the form

=over 8

=item B<category/package>

=item B<-category/package>

=back

It is admissible in these line to use the wildcards *, ?, or [...]
in the usual manner. Every package matching a line is shortened.
Lines with leading B<-> negate a previous shortening.
Later entries can override earlier entries. For instance,

=over 8

=item B<dev-python/*>

=item B<-dev-python/pygtk>

=back

means that all logs of packages of the dev-python category should be shortened
with the exception of the package dev-python/pygtk.
If the lines would have been used in the inverse order

=over 8

=item B<-dev-python/pygtk>

=item B<dev-python/*>

=back

the first line would have no effect since it is negated by the second line.
As an exceptional special case, a line containing only B<-> is equivalent
to the line B<-*> (which means to ignore all previous lines).

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Global Variables

our $VERSION;

# Default for the Options:

my $root = '/';
my $show = '';
my $oldformat = '';
my $keep = 100;
my $keepcolor = '';
my $newer = '';
my $older = '';
my $ignore = '';
my $debug = '';
my $compprg = undef;
my @confdata = ( [ '/etc/logclean.conf' ] );

# Parse Options:

Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
	'help|h', sub { &pod2usage(0) },
	'man|?', sub { &pod2usage(-verbose => 2, -exit => 0) },
	'show!', \$show,
	'pretend!', \$show,
	'p', \$show,
	's', \$show,
	'shorten|S=s', sub { &push_confdata(\@confdata, $_[1]) },
	'shortenfile|f=s', sub { push(@confdata, [ $_[1] ] ) },
	'keepcolor|C', \$keepcolor,
	'gzip|g', sub { $compprg = 'gzip' },
	'bzip2|bzip|b', sub { $compprg = 'bzip2' },
	'lzma|l', sub { $compprg = 'lzma' },
	'xz|x', sub { $compprg = 'xz' },
	'compprog|c', sub { $compprg = $_[1] },
	'ignore|i', \$ignore,
	'debug|d|D', \$debug,
	'oldformat|O', \$oldformat,
	'root|r=s', sub { $root = $_[1] },
	'keep|k=i', sub { $keep = $_[1] },
	'newer|n=i', sub { $newer = $_[1] },
	'older|o=i', sub { $older = $_[1] },
	'version|V', \&version
) or &pod2usage(2);

# Set default variables according to the options:

&pod2usage(2) unless(@ARGV);
$root =~ m{\/$} or $root .= '/';
&fatal('root-directory must be absolute (starting with /)')
	unless($root =~ m{^\/});
&fatal("root-directory $root is no directory") unless(-d $root);

# use File::Which module

{	my $which = undef;  # A static closure
sub which_which {
	return $which if(defined($which));
	eval {
		require File::Which
	};
	$which = ($@ ? '' : 1)
}}

sub have_prg {
	my ($a) = @_;
	if(&which_which()) {
		return defined(File::Which::which($a))
	}
	(system("command -v $a " . '>/dev/null 2>&1') == 0)
}

sub push_confdata {
	my ($cref, $i) = @_;
	$i =~ s{^\s+}{};
	return if(($i eq '') || ($i =~ m{^\#}));
	$i =~ s{\s+$}{};
	if($i =~ m{^\-(?:\*(?:\/\*)?)?$}) {
		@$cref = ()
	} elsif($i =~ m{^\*(?:\/\*)?$}) {
		@$cref = ('*')
	} else {
		push(@$cref, $i)
	}
}

unless(defined($compprg)) {
	if(&have_prg('xz')) {
		$compprg = 'xz'
	} elsif(&have_prg('lzma')) {
		$compprg = 'lzma'
	} elsif(&have_prg('bzip2')) {
		$compprg = 'bzip2'
	} elsif(&have_prg('gzip')) {
		$compprg = 'gzip'
	} else {
		&fatal('cannot find working compression program')
	}
}

{	my $know_conf = '';  # A static closure
sub readconf {
	return if($know_conf);
	$know_conf = 1;
	my @c = ();
	for my $d (@confdata) {
		if(ref($d) eq 'ARRAY') {
			my $file = $d->[0];
			my ($fh, $close);
			if($file eq '-') {
				$fh = \*STDIN;
				$close = ''
			} else {
				unless(open($fh, '<', $file)) {
					&warning('cannot open ', $file);
					next
				}
				$close = 1
			}
			while(<$fh>) {
				push_confdata(\@c, $_)
			}
			close($fh) if($close)
		} else {
			push(@c, $d)
		}
	}
	@confdata = ();
	for (@c) {
		my $negate = '';
		if(m{^\-}) {
			$negate = 1;
			$_ = substr($_, 1)
		}
		s{([^\w\Q*?[]-/\E])}{\\$1}g;
		s{\?}{.}g;
		s{\*}{.*}g;
		my $result = qr{^$_$};
		if($negate) {
			push(@confdata, [ $result ] )
		} else {
			push(@confdata, $result)
		}
	}
}}

sub willshorten {
	my ($file) = @_;
	return '' if($file =~ m{\.(?:(?:[bgx]?z.?)|(?:lz[a-z]*))$}i);
	&readconf();
	$file =~ s{([^:]+)\:(.*)\-\d[^\:]*\:.*}{$1\/$2};
	my $ret = '';
	for my $c (@confdata) {
		if(ref($c) ne 'ARRAY') {
			unless($ret) {
				$ret = 1 if($file =~ m{$c})
			}
		} elsif($ret) {
			for my $neg (@$c) {
				if($file =~ m{$neg}) {
					$ret = '';
					last
				}
			}
		}
	}
	$ret
}

# Get directory paths

my $eix_functions = `command -v eix-functions.sh 2\>/dev/null`;
chomp($eix_functions);
sub getdir {
	my ($name, $default) = @_;
	my $a;
	if($eix_functions ne '') {
		my $source = String::ShellQuote::shell_quote('.', $eix_functions);
		my $readvar = String::ShellQuote::shell_quote('ReadVar', 'x', $name);
		my $printf = String::ShellQuote::shell_quote('printf', '%s');
		$a = `$source \&\& $readvar \&\& $printf \"\$x\"`
	} else {
		my $portageq = String::ShellQuote::shell_quote('portageq', 'envvar', $name);
		$a = `$portageq`;
		chomp($a)
	}
	($a ne '') or $a = $default;
	$a =~ s{^/*}{};
	$a = $root . $a;
	((-d $a) ? $a : '')
}

sub getsub {
	my ($dir, $name) = @_;
	return '' if($dir eq '');
	$name = $dir . '/' . $name;
	((-d $name) ? $name : '')
}

{	my $logdir = undef;  # a static closure
sub getlogdir {
	return $logdir if(defined($logdir));
	$logdir = &getdir('PORT_LOGDIR', '/var/log/portage')
}}

# hash installed packages

my %inames = ();
my %ipaths = ();
my %double = ();

{	my $done = '';  # a static closure
sub getinstalled {
	return if($done);
	$done = 1;
	my $instdir = $root . 'var/db/pkg';
	(-d $instdir) or &fatal('cannot find directory ', $instdir);
	opendir(my $parent, $instdir) or
		&fatal('cannot open directory ', $instdir);
	my $a = undef;
	while($a = readdir($parent), defined($a)) {
		next if $a =~ m{^\.};
		my $fullname = "${instdir}/$a";
		next unless (-d $fullname);
		if(opendir(my $child, $fullname)) {
			my $b = undef;
			while($b = readdir($child), defined($b)) {
				next if($b =~ m{^\.});
				next unless(-d "${fullname}/$b");
				if(exists($inames{$b})) {
					$double{$b} = $inames{$b}
				}
				$inames{$b} = $a;
				$ipaths{"$a/$b"} = ''
			}
			closedir($child)
		}
	}
	closedir($parent)
}}

# read a directory into @files, possibly sorting it lexicographically

sub getfiles {
	my ($dir, $dotfiles) = @_;
	$dotfiles = '' unless(defined($dotfiles));
	my @files = ();
	return () if($dir eq '');
	return () unless(opendir(my $dh, $dir));
	my $a = undef;
	while($a = readdir($dh), defined($a)) {
		if($dotfiles) {
			next if(($a eq '.') || ($a eq '..'))
		} else {
			next if($a =~ m{^\.})
		}
		push(@files, $a)
	}
	closedir($dh);
	@files
}

# test whether file/dir has an allowed date

my $currtime = time();
sub daterange {
	my ($name, $older, $newer) = @_;
	if(($newer eq '') && ($older eq '')) {
		return 1
	}
	my $mtime = (stat($name))[9];
	my $diff = ($currtime - $mtime) / 3600;
	if($newer ne '') {
		return '' if($diff > $newer)
	}
	if($older ne '') {
		return '' if($diff <= $older)
	}
	1
}


# Deletion of dir/file:

sub deldir {
	my ($name, $force) = @_;
	unless($force // '') {
		return unless((-d $name) && !(-l $name))
	}
	return unless(&daterange($name, $older, ''));
	&shprint(['rm', '-rf'], $name);
	return if($show);
	File::Path::remove_tree($name, { error => \my $err });
	for my $diag (@$err) {
		my ($file, $message) = %$diag;
		&warning((($file eq '') ? "when cleaning $name: " :
			"when unlinking $file: ") . $message)
	}
}

sub delfile {
	my ($name, $force) = @_;
	unless($force // '') {
		return unless(-f $name)
	}
	return unless(&daterange($name, $older, ''));
	&shprint('rm', $name);
	return if($show);
	if(unlink($name) != 1) {
		&warning("cannot unlink $name")
	}
}

sub delany {
	my ($name) = @_;
	return unless(&daterange($name, $older, ''));
	if((-d $name) && !(-l $name)) {
		&deldir($name, 1)
	} else {
		&delfile($name, 1)
	}
}

sub renamefile {
	my ($name, $newname) = @_;
	return unless(-f "$name");
	return unless(&daterange($name, $older, ''));
	&shprint('mv', $name, $newname);
	return if($show);
	unless(rename($name, $newname)) {
		&warning("cannot rename $name->$newname")
	}
}


# Test whether file appears to be an installation log:

sub is_install_log {
	my ($file) = @_;
	if($file =~ m{\.(([bgx]?z.?)|(lz[a-z]*))$}i) {
		return 1
	}
	my $ret = '';
	my $fh;
	unless(open($fh, '<', $file)) {
		&debug('cannot read: ', $file) if($debug);
		return ''
	}
	while(<$fh>) {
		if(m{Completed installing}) {
			$ret = 1;
			last
		}
	}
	close($fh);
	$ret
}

# Shorten a logfile.
# We should keep at least the lines which make is_install_log() work correctly

sub shorten_log {
	my ($file) = @_;
	my $write = '';
	my $fh;
	unless(open($fh, '<', $file)) {
		&warning("cannot open $file for reading");
		return ''
	}
	my @A = ();
	my $delete = 0;
	my $mode = 1;
	while(<$fh>) {
		my $push = '';
		if($mode) {
			if(m{Unpacking source}) {
				$mode = '';
				++$delete;
				next
			}
			$push = 1
		} elsif(m{^ \e.*\*}) {
			$push = 1
		}
		if(/Completed installing/) {
			$mode = '';
			$push = 1
		}
		if($push) {
			if($keepcolor) {
				push(@A, $_)
			} else {
				my $strip = colorstrip($_);
				$delete = 2 if(($delete < 2) && ($strip ne $_));
				push(@A, $strip)
			}
		} else {
			++$delete
		}
	}
	close($fh);
	return '' if($delete < 2);
	if($keepcolor) {
		&shprint(['logclean', '--keepcolor'], 'shorten', $file)
	} else {
		&shprint('logclean', 'shorten', $file)
	}
	return 1 if($show);
	&write_to_file($file, \@A)
}

# Uncolor a logfile.

sub uncolor_log {
	return 1 if($keepcolor);
	my ($file) = @_;
	my $fh;
	unless(open($fh, '<', $file)) {
		&warning("cannot open $file for reading");
		return ''
	}
	my $changed = '';
	my @A = ();
	while(<$fh>) {
		my $a = colorstrip($_);
		$changed = 1 unless($changed || ($a ne $_));
		push(@A, $a)
	}
	close($fh);
	return '' unless($changed);
	&shprint('logclean', 'uncolor', $file);
	return 1 if($show);
	return &write_to_file($file, \@A)
}

# Write array to file

sub write_to_file {
	my ($file, $array) = @_;
	my ($atime, $mtime) = (stat($file))[8, 9];
	my $fh;
	unless(open($fh, '>', $file)) {
		&error("cannot open $file for writing");
		return ''
	}
	for my $i (@$array) {
		unless(print($fh $i)) {
			&error("cannot write to $file");
			last
		}
	}
	close($fh);
	utime($atime, $mtime, $file);
	return 1
}


# The main cleanup functions:

sub cleanlogs {
	&getinstalled();
	my $logdir = &getlogdir();
	# Let %nam{"category/name-version"} = [filenames], deleting not installed files
	my %nam = ();
	my %ren = ();
	my @compress = ();
	for my $n (&getfiles($logdir)) {
		my $name;
		my $installed = '';
		if($n =~ m{^([^:]*):([^:]*):}) {
			$name = $1 . '/' . $2;
			if(exists($ipaths{$name})) {
				$installed = 1
			}
		} elsif($n =~ m{^(\d+)\-(.+)\.log(\.(?:(?:[bg]?z.?)|(?:lz[a-z]*)))$}i) {
			my $c = $inames{$2};
			if(defined($c)) {
				$name = $c . '/' . $2;
				$ren{$n} = "${c}:${2}:00000000-${1}.log${3}";
				$installed = 1;
				if(exists($double{$2})) {
					my $conf = $double{$2};
					&warning("conflict between ${c}/${2} and ${conf}/${2}")
				}
			}
		} else {
			next
		}
		if($installed) {
			my $a = $nam{$name};
			if(defined($a)) {
				push(@$a, $n)
			} else {
				$nam{$name} = [$n]
			}
			next
		}
		&debug("not installed: ", $n) if($debug);
		&delfile($logdir . '/' . $n)
	}
	NAMELOOP:for my $n (sort(keys(%nam))) {
		my $namref = $nam{$n};
		# my @fnames = sort { $a <=> $b } (@$namref);
		my @fnames = sort {
				((stat($logdir . '/' . $a))[9]) <=>
				((stat($logdir . '/' . $b))[9])
			} (@$namref);
		# Possibly erase one element from the list: The file to keep.
		# Also push this file to @compress if it was not already compressed.
		my $eraseexcept = undef;
		for(my $i = $#fnames; $i >= 0; --$i) {
			my $fname = $fnames[$i];
			if(defined($eraseexcept)) {
				&debug("later log $eraseexcept exists: ", $fname)
					if($debug);
				next
			}
			my $fpath = $logdir . '/' . ${fname};
			next unless(-f $fpath);
			next NAMELOOP unless(&daterange($fpath, '', $newer));
			unless(&is_install_log($fpath)) {
				&debug('no installation log: ', $fname)
					if($debug);
				next
			}
			my $r = $ren{$fname};
			if(defined($r)) {
				&renamefile($fpath, $logdir . '/' . $r)
			}
			splice(@fnames, $i, 1);
			$eraseexcept = $fname;
			if($eraseexcept =~ m{\.log$}i) {
				push(@compress, $eraseexcept)
			}
		}
		for my $fname (@fnames) {
			&delfile($logdir . '/' . $fname)
		}
	}
	# Compress the files...
	for my $f (@compress) {
		my $file = $logdir . '/' . $f;
		if(&willshorten($f)) {
			&shorten_log($file)
		} else {
			&uncolor_log($file)
		}
		if($compprg ne '') {
			&shprint($compprg, $file);
			next if($show);
			if(system($compprg, $file) != 0) {
				&warning('failed: ', &shdash($compprg, $file))
			}
		}
	}
}

# A possible replacement for &cleanlogs if certainly no "dummy" logs can exist.
# This function is currently not used but might be used in a future version
sub cleanlogs_new_stupid {
	&getinstalled();
	my $logdir = &getlogdir();
	my $previous = '';
	my $previous_mtime = '';
	my ($previous_name, $previous_debugname);
	for my $file (sort(&getfiles($logdir))) {
		my $name = $logdir . '/' . $file;
		$file =~ m{^([^:]*):([^:]*):} and (-f $name) or next;
		my $current = $1 . '/' . $2;
		my $debugname = $file;
		if(!exists($ipaths{$current})) {
			&debug('not installed: ', $debugname) if($debug);
			&delfile($name);
			next
		}
		if($current eq $previous) {
			my $mtime = (stat($name))[9];
			if($previous_mtime eq '') {
				$previous_mtime = (stat($previous_name))[9]
			}
			if($mtime < $previous_mtime) {
				&debug('newer log exists: ', $debugname)
					if($debug);
				&delfile($name);
				next
			}
			&debug('newer log exists: ', ${previous_debugname})
				if($debug);
			&delfile($previous_name);
			$previous_mtime = $mtime
		} else {
			$previous_mtime = '';
			$previous = $current
		}
		$previous_name = $name;
		$previous_debugname = $debugname
	}
}

sub cleanelogs {
	&getinstalled();
	my $logdir = &getlogdir();
	my $elogdir = &getsub($logdir, 'elog');
	my @files = sort(&getfiles($elogdir));
	for(my $i = 0; $i < @files; ) {
		$_ = $files[$i++];
		my $name = $elogdir . '/' . $_;
		next unless(-f $name);
		next unless(m{^([^:]*):([^:]*):});
		if((! (($i < @files) && (index($files[$i], "$1:$2:") == $[))) &&
			exists($ipaths{$1 . '/' . $2})) {
			next unless(&daterange($name, $older, $newer));
			my $willclean = 1;
			my $fh;
			next unless open($fh, '<', $name);
			while(<$fh>) {
				chomp();
				s{\s*$}{};
				next if($_ eq '');
				s{^\s*}{};
				next if(m{^[A-Z]*:\s\S*$}i);
				next if(m{^\S*abling confcache}i);
				next if(m{^\S*\s?\S*FLAGS contain\S* \S* which can break package}i);
				next if(m{^Before you file a bug}i);
				next if(m{^re-compile the package in question}i);
				next if(m{^[A-Z]\S*ing });
				next if(m{^\s*\>\>\>\s*SetUID});
				next if(m{^\s*\.\.\.\s*$});
				next if(m{^Byte compiling }i);
				$willclean = '';
				last
			}
			close($fh);
			next unless($willclean)
		}
		&delfile($name)
	}
}

sub cleannotes {
	&getinstalled();
	my $noticedir = &getdir('PORT_ENOTICE_DIR', '/var/log/notices');
	for my $file (sort(&getfiles($noticedir))) {
		my $name = $noticedir . '/' . $file;
		next unless(-f $name);
		if(exists($inames{$file})) {
			next unless(&daterange($name, $older, $newer));
			my $willclean = 1;
			my $fh;
			next unless(open($fh, '<', $name));
			while(<$fh>) {
				chomp();
				s{\s*$}{};
				next if($_ eq '');
				next if(m{^[a-z]*:$});
				next if(m{^info:\s*(?:Applying)?\s*\S*\.(?:diff|patch)(?:\.\S*)?(?:\s*\.\.\.)?$}i);
				next if(m{^info:\s*(?:Updating|Using)\s*\S*$}i);
				next if(m{^info:Running eautoreconf in }i);
				next if(m{^info:Applying various patches}i);
				next if(m{^info:Done with patching}i);
				next if(m{^info:Excluding patches}i);
				next if(m{^info:Using GNU config files from }i);
				$willclean = '';
				last
			}
			close($fh);
			next unless($willclean)
		}
		&delfile($name)
	}
}

sub cleanbuilds {
	my $porttmp = &getdir('PORTAGE_TMPDIR', '/var/tmp');
	my $builddir = &getsub($porttmp, 'portage');
	for my $i (&getfiles($builddir, 1)) {
		next if($i eq 'homedir');
		&deldir($builddir . '/' . $i)
	}
}

sub cleancache {
	my $cachedir = $root . 'var/cache/edb/dep';
	for my $i (&getfiles($cachedir, 1)) {
		&delany($cachedir . '/' . $i)
	}
}

sub cleanrevdep {
	my $revdepdir = $root . 'var/cache/revdep-rebuild';
	for my $i (&getfiles($revdepdir, 1)) {
		&delany($revdepdir . '/' . $i)
	}
}

sub cleanemerge {
	&getinstalled() unless($ignore);
	my $file = $root . 'var/log/emerge.log';
	my @start =();
	my @lines=();  # $line or [ 'category/name-version', $line ]
	my %success=();  # undef or [ completed, start1, start2 ]
	open(my $fh, '<', $file) or &fatal("cannot open $file for reading");
	while(<$fh>) {
		next unless(m{^\d+:\s*(.*)$}o);
		push(@lines, $_);
		$_ = $1;
		if(m{^Started\s+emerge}io) {
			push(@start, $#lines);
			if($keep < @start) {
				shift(@start)
			}
		} elsif(m{^\>\>\>\s+emerge\s+\([^\)]+\)\s+([^\s]+)}io) {
			unless($ignore) {
				next unless(exists($ipaths{$1}));
			}
			$lines[$#lines] = [$1, $lines[$#lines] ];
			my $s = $success{$1};
			if(ref($s) ne '') {
				if($s->[1] < 0) {
					$s->[1] = $#lines
				} else {
					$s->[2] = $#lines
				}
			} else {
				$success{$1} = [ -1, $#lines, -1 ]
			}
		} elsif(m{^\:\:\:\s+completed\s+emerge\s+\([^\)]+\)\s+([^\s]*)}io) {
			unless($ignore) {
				next unless(exists($ipaths{$1}))
			}
			$lines[$#lines] = [$1, $lines[$#lines] ];
			my $s = $success{$1};
			if(ref($s) ne '') {
				$s->[0] = $#lines;
				if($s->[2] >= 0) {
					$s->[1] = $s->[2]
				}
			} else {
				$success{$1} = [ $#lines, -1, -1 ]
			}
		} elsif(m{^\>\>\>\s+unmerge\s+success:\s+([^\s]*)}io) {
			my $s = $success{1};
			if(ref($s) ne '') {
				$s->[0] = -1
			}
		}
	}
	close($fh);
	my $firstline = $#lines + 1;
	$firstline = $start[0] if(@start);
	unless($debug) {
		open($fh, '>', $file) or &fatal("cannot open $file for writing")
	}
	my $fail = '';
	for(my $i = 0; $i < @lines; ++$i) {
		my $line = $lines[$i];
		if(ref($line) ne '') {
			if($i < $firstline) {
				my $s = $success{$line->[0]};
				if(ref($s) ne '') {
					next unless(($s->[0] >= 0) && (($s->[0] == $i) || ($s->[1] == $i)));
				}
			}
			if($debug) {
				print($line->[1])
			} else {
				print($fh ($line->[1])) or $fail = 1
			}
		} elsif($i >= $firstline) {
			if($debug) {
				print($line)
			} else {
				print($fh $line) or $fail = 1
			}
		}
	}
	unless($debug) {
		close($fh) or $fail = 1
	}
	&fatal("failed to write $file properly") if($fail)
}

sub shprint {
	print(&shdash, "\n")
}

sub shdash {
	my $c = shift();
	$c = [$c] unless(ref($c) eq 'ARRAY');
	for my $i (@_) {
		if($i =~ m{^[-+]}o) {
			push(@$c, '--');
			last
		}
	}
	String::ShellQuote::shell_quote(@$c, @_)
}

sub pod2usage {
	require Pod::Usage;
	&Pod::Usage::pod2usage
}

sub message {
	print(STDERR 'logclean: ', @_, "\n")
}

sub debug {
	&message('debug: ', @_)
}

sub warning {
	&message('warning: ', @_)
}

sub error {
	&message('error: ', @_)
}

sub fatal {
	&error;
	exit(1)
}

sub version {
	print('logclean ', $VERSION, "\n");
	exit(0)
}

# Execute main functions according to the argument(s):

my $shortenmode = '';
my $uncolormode = '';
for (@ARGV) {
	if($shortenmode) {
		&shorten_log($_)
	} elsif($uncolormode) {
		&uncolor_log($_)
	} elsif(m{^emerg}i) {
		&cleanemerge()
	} elsif(m{^log}i) {
		&cleanlogs()
	} elsif(m{^elog}i) {
		&cleanelogs()
	} elsif(m{^e?not(?:ic)?e}i) {
		&cleannotes()
	} elsif(m{^build|te?mp}i) {
		&cleanbuilds()
	} elsif(m{^cach}i) {
		&cleancache()
	} elsif(m{^revdep|rebuild}i) {
		&cleanrevdep()
	} elsif(m{^all}i) {
		&cleanemerge();
		&cleanlogs();
		&cleanelogs();
		&cleannotes();
		&cleancache();
		&cleanrevdep();
		&cleanbuilds()
	} elsif(m{^help}i) {
		 &pod2usage(0)
	} elsif(m{^man}i) {
		 &pod2usage(-verbose => 2, -exit => 0)
	} elsif(m{^short}i) {
		$shortenmode = 1
	} elsif(m{^uncol}i) {
		$uncolormode = 1
	} else {
		&fatal('unknown argument ', $_)
	}
}
1;
